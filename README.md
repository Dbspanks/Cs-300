# Cs-300
What was the problem you were solving in the projects for this course?

The main problem we were trying to sovle in this course involved our ablility to understand and implement a sorting and searching algorithm for our data structure. For this we needed to understand the differences between using a Vecotr, Hash Table, or a BST. Our lesson was focused on understanding how each one works, and what are the beneifts or pitfalls of each choice. We were tasked with creating pseudocode for each option, and reflect on the reasons why we would could each option. 

How did you approach the problem? Consider why data structures are important to understand.

I approached this problem by reading about each method and their strengths and weakneeses. I also looked at examples of each type and practiced useing each. The work we did in the zybooks helped to understand the implemiation of each type. The importance of our understanding of these data structures is key in our ability to write code that is effecient, powerful and capable of doing what we expect it to. 

How did you overcome any roadblocks you encountered while going through the activities or project?

I had roadblocks with BST and Hash Tables, The issues were not with understanding how they worked as I can connect them to how I would use them in math, my challenges came in learning how to code these concepts, I struggled with the placement of the hash table and the order of funtions to make these work. When it came to BST this was not as bad for me but I still struggled with the left/right at first.

How has your work on this project expanded your approach to designing software and developing programs?

My work on this project has helped me to see that there is more than one way to accomplish a task. All three data structures were capable of handleing the requirements of our project. However, just because it works and might be easier to write, it might not be the best choice for our needs. This then leads us to having a firm understanding of needs of our program. We need to know what are we trying to do, why are we doing it, and what is the most important feature for it.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

This class and our assignements to write psuedocode for each structure, but still using the same menu and cases, really allowed us to learn how if we write a clean and solid code or pseudocode, we can reuse portions of our work while we progress in our project. This helped me to really understand the idea of what it means to be adaptable and maintainable.
